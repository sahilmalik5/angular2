"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var core_1 = require('@angular/core');
var async_1 = require('rxjs/scheduler/async');
require('rxjs/add/operator/debounceTime');
require('rxjs/add/operator/take');
require('rxjs/add/operator/publish');
require('rxjs/add/operator/observeOn');
var Idle = (function () {
    function Idle(ngZone) {
        this.ngZone = ngZone;
        this.idleHandlers = new Map();
        this.stableObservable$ = this.ngZone
            .onStable
            .observeOn(async_1.async)
            .publish()
            .refCount();
    }
    Idle.prototype.requestIdleCallback = function (callback) {
        if ('requestIdleCallback' in window) {
            window['requestIdleCallback'](callback);
        }
        else {
            this.polyfillRequestIdleCallback(callback);
        }
    };
    Idle.prototype.cancelIdleCallback = function (handler) {
        if ('cancelIdleCallback' in window) {
            window['cancelIdleCallback'](handler);
        }
        else {
            this.polyfillCancelIdleCallback(handler);
        }
    };
    Idle.prototype.polyfillCancelIdleCallback = function (handler) {
        var _a = this.idleHandlers.get(handler), unsubscribe = _a.unsubscribe, timerId = _a.timerId;
        if (unsubscribe) {
            unsubscribe();
        }
        if (timerId) {
            this.ngZone.runOutsideAngular(function () {
                clearTimeout(timerId);
            });
        }
        this.idleHandlers.delete(handler);
    };
    Idle.prototype.polyfillRequestIdleCallback = function (callback, _a) {
        var _this = this;
        var timeout = (_a === void 0 ? { timeout: 50 } : _a).timeout;
        var dispose = undefined;
        // compiling problem
        var _self = this;
        _self.ngZone.runOutsideAngular(function () {
            function cb() {
                var start = Date.now();
                var deadline = {
                    didTimeout: false,
                    timeRemaining: function () {
                        return Math.max(0, 50 - (Date.now() - start));
                    }
                };
                setTimeout(function () {
                    deadline.didTimeout = true;
                    if (dispose) {
                        dispose.unsubscribe();
                    }
                }, timeout || 50);
                callback(deadline);
            }
            if (_this.ngZone.isStable) {
                var timerId = setTimeout(cb, 10);
                _this.idleHandlers.set(callback, {
                    timerId: timerId
                });
            }
            else {
                dispose = _this.stableObservable$
                    .debounceTime(10)
                    .take(1)
                    .subscribe(function () {
                    var timerId = setTimeout(cb, 10);
                    _this.idleHandlers.set(callback, {
                        unsubscribe: dispose.unsubscribe,
                        timerId: timerId
                    });
                });
                _this.idleHandlers.set(callback, {
                    unsubscribe: dispose.unsubscribe
                });
            }
        });
    };
    Idle = __decorate([
        core_1.Injectable(), 
        __metadata('design:paramtypes', [core_1.NgZone])
    ], Idle);
    return Idle;
}());
exports.Idle = Idle;
exports.ANGULARCLASS_IDLE_PROVIDERS = [
    Idle
];
function setupPrefetchInitializer(injector, callbacks) {
    var defaultReturnValue = function () { return null; };
    if (!callbacks || !callbacks.length) {
        return defaultReturnValue;
    }
    // https://github.com/angular/angular/issues/9101
    // Delay to avoid circular dependency
    setTimeout(function () {
        var appRef = injector.get(core_1.ApplicationRef);
        if (appRef.componentTypes.length === 0) {
            appRef.registerBootstrapListener(function () {
                var idle = injector.get(Idle);
                callbacks.forEach(function (cb) { return idle.requestIdleCallback(cb); });
            });
        }
        else {
            var idle_1 = injector.get(Idle);
            callbacks.forEach(function (cb) { return idle_1.requestIdleCallback(cb); });
        }
    }, 0);
    return defaultReturnValue;
}
exports.setupPrefetchInitializer = setupPrefetchInitializer;
function providePrefetchIdleCallbacks(prefetchCallbacks) {
    if (prefetchCallbacks === void 0) { prefetchCallbacks = []; }
    return exports.ANGULARCLASS_IDLE_PROVIDERS.concat([
        // Trigger initial navigation
        { provide: core_1.APP_INITIALIZER, multi: true, useFactory: function (injector) {
                return setupPrefetchInitializer(injector, prefetchCallbacks);
            }, deps: [core_1.Injector] }
    ]);
}
exports.providePrefetchIdleCallbacks = providePrefetchIdleCallbacks;
//# sourceMappingURL=index.js.map